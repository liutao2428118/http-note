# 缓存

为什么要缓存：

1. 缓存减少了冗余的数据传输，节省了你的网络费用。
2. 缓存缓解了网络瓶颈的问题，不需要更多的带宽就能够更快地加载页面。
3. 缓存降低了对原始服务器的要求，服务器可以更快地响应，避免过载的出现。
4. 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。

## 命中和未命中的

缓存也并不是保存 世界是哪个所以的每份文档副本。如果副本为某些请求提供了缓存副本，被称为缓存命中，如果没请求到缓存副本本称为 缓存未命中。

### 再验证

原始服务器的内容可能发生变化，缓存要时不时对其进去检测，看看当前报错的副本是不是最新的，这样的新鲜度检测被称为 HTTP 再验证。

缓存可以任意时刻，以任意的频率对副本进行再验证。但是由于缓存中的通常会保存百万份副本，而且网络带宽也是很珍贵的，所以再验证也是需要一些规则来进行的。

缓存在对副本在再验证的的时候，一般会向原始服务器发送一段小的再验证请求。如果没变化，服务器会返回一个小的 304 响应。如果有变化就返回全部报文。

HTTP 为我们提供了几个用来对缓存对象进行再验证的首部，最常用的时候 IF-Modified-Since 首部。

### 命中率

由缓存提供服务的请求所占的比例被称为缓存命中率。

字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。

## 缓存的拓扑结构

1. 私有缓存
2. 公有的代理缓存

### 代理缓存的层次结构

在实际中，实现层次化的缓存是很有意义的。在这种结构中，在较小缓存中未命中的请求会被导向较大的父缓存。

在层次结构很深的情况下，请求可能要穿过很长一溜缓存，每个拦截代理都会添加一些性能损耗，当代理链过长时，这种损耗会变得非常明显。

### 网状缓存、内容路由以及对等缓存

有些网络结构会构建复杂的网状缓存，而不是简单的缓存层次结构。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为内容路由器。

## 缓存的处理步骤

1. 接收-缓存从网络中读取抵达的请求报文
2. 解析-缓存对报文进行解析，提取出 URL 和各种首部
3. 查询-缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存带本地）
4. 新鲜度检测-缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。
5. 创建响应-缓存会用新的首部和已缓存的主体来构建一条响应报文。
6. 发送-缓存通过网络将响应发回给客户端。
7. 日志-缓存可选的创建一个日志文件条目来描述这个事务。

![Image text](/images/1648087854(1).png)

## 保持副本的新鲜度

缓存保存的副本会随着时间的变化而与服务器文档没保持一致，这样就需要一个机制来询问服务器缓存的副本是否可用，HTTp 将这些简单的机制称为 文档过期和服务器再验证。

### 文档过期（强缓存）

通过 HTTP 的首部 Cache-Contrlo 和 Expires 来确定当前文档是否过期。在缓存文档过期之前，缓存可以以任意频率使用副本，无需月服务器联系。

过期日期的使用：

![Image text](/images/1648088870(1).png)

Expires 和 Cache-Control: max-age 本质是一样的，只不过 Cache-Control 首部用的的是相对时间而不是绝对时间

### 服务器再验证（协商缓存）

也是就是缓存文档过期了并不代表缓存文档与原服务器上的文档有区别，这样的情况是需要询问下原服务器缓存文档是否修改了。

* 如果是修改过了，缓存获取新文本副本，并存储在旧文档的位置，然后给客户端
* 如果是没修改过，缓存获取到到一个 304 响应首部

HTTP 是通过两个常用条件首部来进行再验证（协议缓存）的：

![Image text](/images/1648089809(1).png)

#### IF-Modified-Since: 时间

IF-Modified-Since 通常与响应首部 Last-Modified 配合使用，当缓存要对缓存副本进行再验证的时候，请求首部会包含一个IF-Modified-Since 并携带上次响应报文中的 Last-Modified 值（最后修改时间）来询问服务器副本是否被修改了。

语法：

```js
If-Modified-Since: <cached last-modified date>
```

#### IF-None-Match: 摘要

IF-None-Match 与 响应首部 ETag （版本标识符）配合使用，缓存可以通过 IF-None-Match 带上 ETag 来询问服务器是否有新的副本，IF-None-Match 带上多个版本号来告诉服务器我本地缓存已有哪些副本了

#### 如何选择条件首部

如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果服务器只回送了一个 Last-Modified 值，客户端就可以使用 If-Modified-Since 验证。 如果实体标签和最近修改日期都返回了，客户端就应该使用这两种再验证方案。只有这两个条件都满足时，代理或服务器才能返回 304 Not Modified。

## 控制缓存的能力（缓存的其他首部能力）

服务器通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序：

1. ```Cache-Control: no-store``` 禁止缓存副本，并向客户端发送一条 no-store 响应。
2. ```Cache-Control: no-cache``` 可以缓存副本，不过每次都要向原服务器验证一下新鲜度，在提供给客户端。另外为了兼容 HTTP/1.0+ , 1.1 还提供了 Pragma: no-cache 首部
3. ```Cache-Control: max-age``` 表示从服务器将文档传来之时起，此文档新鲜度的秒数。
4. ``` Expires``` 首部指定的是实际的过期实际而不是秒数，绝对时间。
5. ```Cache-Control: must-revalidate``` 首部告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不要提供陈旧副本。

## 客户端的新鲜度限制

客户端可以通过 Cache-Control 请求首部来强化或放松对过期时间的限制。

![Image text](/images/1648106585(1).png)
